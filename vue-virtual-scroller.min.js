const VueVirtualScroller = ((e, t) => {
  t = t?.hasOwnProperty('default') ? t.default : t;
  const i = { itemsLimit: 1e3 };
  let n = void 0;
  function r() {
    r.init ||
      ((r.init = !0),
      (n =
        -1 !==
        (() => {
          const e = window.navigator.userAgent;
          const t = e.indexOf('MSIE ');
          if (t > 0) return Number.parseInt(e.substring(t + 5, e.indexOf('.', t)), 10);
          if (e.indexOf('Trident/') > 0) {
            const i = e.indexOf('rv:');
            return Number.parseInt(e.substring(i + 3, e.indexOf('.', i)), 10);
          }
          const n = e.indexOf('Edge/');
          return n > 0 ? Number.parseInt(e.substring(n + 5, e.indexOf('.', n)), 10) : -1;
        })()));
  }
  const o = {
    render: function () {
      const e = this.$createElement;
      return (this._self._c || e)('div', { staticClass: 'resize-observer', attrs: { tabindex: '-1' } });
    },
    staticRenderFns: [],
    _scopeId: 'data-v-b329ee4c',
    name: 'resize-observer',
    methods: {
      compareAndNotify: function () {
        (this._w === this.$el.offsetWidth && this._h === this.$el.offsetHeight) ||
          ((this._w = this.$el.offsetWidth), (this._h = this.$el.offsetHeight), this.$emit('notify'));
      },
      addResizeHandlers: function () {
        this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify),
          this.compareAndNotify();
      },
      removeResizeHandlers: function () {
        this._resizeObject?.onload &&
          (!n &&
            this._resizeObject.contentDocument &&
            this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify),
          (this._resizeObject.onload = undefined));
      },
    },
    mounted: function () {
      r(),
        this.$nextTick(() => {
          (this._w = this.$el.offsetWidth), (this._h = this.$el.offsetHeight);
        });
      const t = document.createElement('object');
      (this._resizeObject = t),
        t.setAttribute('aria-hidden', 'true'),
        t.setAttribute('tabindex', -1),
        (t.onload = this.addResizeHandlers),
        (t.type = 'text/html'),
        n && this.$el.appendChild(t),
        (t.data = 'about:blank'),
        n || this.$el.appendChild(t);
    },
    beforeDestroy: function () {
      this.removeResizeHandlers();
    },
  };
  const s = {
    version: '0.4.5',
    install: (e) => {
      e.component('resize-observer', o), e.component('ResizeObserver', o);
    },
  };
  let l = null;
  'undefined' !== typeof window ? (l = window.Vue) : 'undefined' !== typeof global && (l = global.Vue), l?.use(s);
  const a =
    'function' === typeof Symbol && 'symbol' === typeof Symbol.iterator
      ? (e) => typeof e
      : (e) =>
          e && 'function' === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
  const c =
    ((() => {
      function e(e) {
        this.value = e;
      }
      function t(t) {
        let i;
        let n;
        function r(i, n) {
          try {
            const s = t[i](n);
            const l = s.value;
            l instanceof e
              ? Promise.resolve(l.value).then(
                  (e) => {
                    r('next', e);
                  },
                  (e) => {
                    r('throw', e);
                  },
                )
              : o(s.done ? 'return' : 'normal', s.value);
          } catch (e) {
            o('throw', e);
          }
        }
        function o(e, t) {
          switch (e) {
            case 'return':
              i.resolve({ value: t, done: !0 });
              break;
            case 'throw':
              i.reject(t);
              break;
            default:
              i.resolve({ value: t, done: !1 });
          }
          (i = i.next) ? r(i.key, i.arg) : (n = null);
        }
        (this._invoke = (e, t) =>
          new Promise((o, s) => {
            const l = { key: e, arg: t, resolve: o, reject: s, next: null };
            n ? (n = n.next = l) : ((i = n = l), r(e, t));
          })),
          'function' !== typeof t.return && (this.return = void 0);
      }
      'function' === typeof Symbol &&
        Symbol.asyncIterator &&
        (t.prototype[Symbol.asyncIterator] = function () {
          return this;
        }),
        (t.prototype.next = function (e) {
          return this._invoke('next', e);
        }),
        (t.prototype.throw = function (e) {
          return this._invoke('throw', e);
        }),
        (t.prototype.return = function (e) {
          return this._invoke('return', e);
        });
    })(),
    (e, t) => {
      if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
    });
  const u = (() => {
    function e(e, t) {
      for (let i = 0; i < t.length; i++) {
        const n = t[i];
        (n.enumerable = n.enumerable || !1),
          (n.configurable = !0),
          'value' in n && (n.writable = !0),
          Object.defineProperty(e, n.key, n);
      }
    }
    return (t, i, n) => (i && e(t.prototype, i), n && e(t, n), t);
  })();
  const d = (e) => {
    if (Array.isArray(e)) {
      for (let t = 0, i = Array(e.length); t < e.length; t++) i[t] = e[t];
      return i;
    }
    return Array.from(e);
  };
  const h = (() => {
    function e(t, i, n) {
      c(this, e), (this.el = t), (this.observer = null), (this.frozen = !1), this.createObserver(i, n);
    }
    return (
      u(e, [
        {
          key: 'createObserver',
          value: function (e, t) {
            let i;
            let n;
            let r;
            let o;
            let s;
            let l;
            let a;
            (this.observer && this.destroyObserver(), this.frozen) ||
              ((this.options = 'function' === typeof (i = e) ? { callback: i } : i),
              (this.callback = this.options.callback),
              this.callback &&
                this.options.throttle &&
                (this.callback =
                  ((n = this.callback),
                  (r = this.options.throttle),
                  (o = void 0),
                  (s = void 0),
                  (l = void 0),
                  ((a = (e) => {
                    for (let t = arguments.length, i = Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
                      i[a - 1] = arguments[a];
                    (l = i),
                      (o && e === s) ||
                        ((s = e),
                        clearTimeout(o),
                        (o = setTimeout(() => {
                          n.apply(void 0, [e].concat(d(l))), (o = 0);
                        }, r)));
                  })._clear = () => {
                    clearTimeout(o);
                  }),
                  a)),
              (this.oldResult = void 0),
              (this.observer = new IntersectionObserver((e) => {
                const t = e[0];
                if (this.callback) {
                  const i = t.isIntersecting && t.intersectionRatio >= this.threshold;
                  if (i === this.oldResult) return;
                  (this.oldResult = i),
                    this.callback(i, t),
                    i && this.options.once && ((this.frozen = !0), this.destroyObserver());
                }
              }, this.options.intersection)),
              t.context.$nextTick(() => {
                this.observer.observe(this.el);
              }));
          },
        },
        {
          key: 'destroyObserver',
          value: function () {
            this.observer && (this.observer.disconnect(), (this.observer = null)),
              this.callback?._clear && (this.callback._clear(), (this.callback = null));
          },
        },
        {
          key: 'threshold',
          get: function () {
            return this.options.intersection?.threshold || 0;
          },
        },
      ]),
      e
    );
  })();
  function f(e, t, i) {
    const n = t.value;
    if ('undefined' === typeof IntersectionObserver)
      console.warn(
        '[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill',
      );
    else {
      const r = new h(e, n, i);
      e._vue_visibilityState = r;
    }
  }
  const v = {
    bind: f,
    update: (e, t, i) => {
      const n = t.value;
      if (
        !(function e(t, i) {
          if (t === i) return !0;
          if ('object' === (void 0 === t ? 'undefined' : a(t))) {
            for (const n in t) if (!e(t[n], i[n])) return !1;
            return !0;
          }
          return !1;
        })(n, t.oldValue)
      ) {
        const r = e._vue_visibilityState;
        r ? r.createObserver(n, i) : f(e, { value: n }, i);
      }
    },
    unbind: (e) => {
      const t = e._vue_visibilityState;
      t && (t.destroyObserver(), (e._vue_visibilityState = undefined));
    },
  };
  const p = {
    version: '0.4.3',
    install: (e) => {
      e.directive('observe-visibility', v);
    },
  };
  let m = null;
  'undefined' !== typeof window ? (m = window.Vue) : 'undefined' !== typeof global && (m = global.Vue), m?.use(p);
  const y =
    'undefined' !== typeof window
      ? window
      : 'undefined' !== typeof global
        ? global
        : 'undefined' !== typeof self
          ? self
          : {};
  let b;
  const g =
    (((e) => {
      let t;
      let i;
      (t = y),
        (i = () => {
          const e = /(auto|scroll)/;
          const t = (e, i) => (null === e.parentNode ? i : t(e.parentNode, i.concat([e])));
          const i = (e, t) => getComputedStyle(e, null).getPropertyValue(t);
          const n = (t) => e.test(((e) => i(e, 'overflow') + i(e, 'overflow-y') + i(e, 'overflow-x'))(t));
          return (e) => {
            if (e instanceof HTMLElement || e instanceof SVGElement) {
              for (let i = t(e.parentNode, []), r = 0; r < i.length; r += 1) if (n(i[r])) return i[r];
              return document.scrollingElement || document.documentElement;
            }
          };
        }),
        e.exports ? (e.exports = i()) : (t.Scrollparent = i());
    })((b = { exports: {} }), b.exports),
    b.exports);
  const _ =
    'function' === typeof Symbol && 'symbol' === typeof Symbol.iterator
      ? (e) => typeof e
      : (e) =>
          e && 'function' === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
  const w =
    ((() => {
      function e(e) {
        this.value = e;
      }
      function t(t) {
        let i;
        let n;
        function r(i, n) {
          try {
            const s = t[i](n);
            const l = s.value;
            l instanceof e
              ? Promise.resolve(l.value).then(
                  (e) => {
                    r('next', e);
                  },
                  (e) => {
                    r('throw', e);
                  },
                )
              : o(s.done ? 'return' : 'normal', s.value);
          } catch (e) {
            o('throw', e);
          }
        }
        function o(e, t) {
          switch (e) {
            case 'return':
              i.resolve({ value: t, done: !0 });
              break;
            case 'throw':
              i.reject(t);
              break;
            default:
              i.resolve({ value: t, done: !1 });
          }
          (i = i.next) ? r(i.key, i.arg) : (n = null);
        }
        (this._invoke = (e, t) =>
          new Promise((o, s) => {
            const l = { key: e, arg: t, resolve: o, reject: s, next: null };
            n ? (n = n.next = l) : ((i = n = l), r(e, t));
          })),
          'function' !== typeof t.return && (this.return = void 0);
      }
      'function' === typeof Symbol &&
        Symbol.asyncIterator &&
        (t.prototype[Symbol.asyncIterator] = function () {
          return this;
        }),
        (t.prototype.next = function (e) {
          return this._invoke('next', e);
        }),
        (t.prototype.throw = function (e) {
          return this._invoke('throw', e);
        }),
        (t.prototype.return = function (e) {
          return this._invoke('return', e);
        });
    })(),
    (e, t, i) => (
      t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : (e[t] = i), e
    ));
  const S =
    Object.assign ||
    ((e) => {
      for (let t = 1; t < arguments.length; t++) {
        const i = arguments[t];
        for (const n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]);
      }
      return e;
    });
  const $ = {
    items: { type: Array, required: !0 },
    keyField: { type: String, default: 'id' },
    direction: { type: String, default: 'vertical', validator: (e) => ['vertical', 'horizontal'].includes(e) },
  };
  function z() {
    return this.items.length && 'object' !== _(this.items[0]);
  }
  let x = !1;
  if ('undefined' !== typeof window) {
    x = !1;
    try {
      const k = Object.defineProperty({}, 'passive', {
        get: () => {
          x = !0;
        },
      });
      window.addEventListener('test', null, k);
    } catch (e) {}
  }
  let I = 0;
  const D = {
    render: function () {
      const t = this.$createElement;
      const i = this._self._c || t;
      return i(
        'div',
        {
          directives: [
            {
              name: 'observe-visibility',
              rawName: 'v-observe-visibility',
              value: this.handleVisibilityChange,
              expression: 'handleVisibilityChange',
            },
          ],
          staticClass: 'vue-recycle-scroller',
          class: w({ ready: this.ready, 'page-mode': this.pageMode }, `direction-${this.direction}`, !0),
          on: { '&scroll': (t) => this.handleScroll(t) },
        },
        [
          this.$slots.before
            ? i('div', { staticClass: 'vue-recycle-scroller__slot' }, [this._t('before')], 2)
            : this._e(),
          this._v(' '),
          i(
            'div',
            {
              ref: 'wrapper',
              staticClass: 'vue-recycle-scroller__item-wrapper',
              style: w({}, 'vertical' === this.direction ? 'minHeight' : 'minWidth', `${this.totalSize}px`),
            },
            this._l(this.pool, (t) =>
              i(
                'div',
                {
                  key: t.nr.id,
                  staticClass: 'vue-recycle-scroller__item-view',
                  class: { hover: this.hoverKey === t.nr.key },
                  style: this.ready
                    ? {
                        transform: `translate${'vertical' === this.direction ? 'Y' : 'X'}(${t.position}px)`,
                      }
                    : null,
                  on: {
                    mouseenter: (i) => {
                      this.hoverKey = t.nr.key;
                    },
                    mouseleave: (t) => {
                      this.hoverKey = null;
                    },
                  },
                },
                [this._t('default', null, { item: t.item, index: t.nr.index, active: t.nr.used })],
                2,
              ),
            ),
            0,
          ),
          this._v(' '),
          this.$slots.after
            ? i('div', { staticClass: 'vue-recycle-scroller__slot' }, [this._t('after')], 2)
            : this._e(),
          this._v(' '),
          i('ResizeObserver', { on: { notify: this.handleResize } }),
        ],
        1,
      );
    },
    staticRenderFns: [],
    name: 'RecycleScroller',
    components: { ResizeObserver: o },
    directives: { ObserveVisibility: v },
    props: S({}, $, {
      itemSize: { type: Number, default: null },
      minItemSize: { type: [Number, String], default: null },
      sizeField: { type: String, default: 'size' },
      typeField: { type: String, default: 'type' },
      buffer: { type: Number, default: 200 },
      pageMode: { type: Boolean, default: !1 },
      prerender: { type: Number, default: 0 },
      emitUpdate: { type: Boolean, default: !1 },
    }),
    data: () => ({ pool: [], totalSize: 0, ready: !1, hoverKey: null }),
    computed: {
      sizes: function () {
        if (null === this.itemSize) {
          for (
            let e = { '-1': { accumulator: 0 } },
              t = this.items,
              i = this.sizeField,
              n = this.minItemSize,
              r = 0,
              o = void 0,
              s = 0,
              l = t.length;
            s < l;
            s++
          )
            (r += o = t[s][i] || n), (e[s] = { accumulator: r, size: o });
          return e;
        }
        return [];
      },
      simpleArray: z,
    },
    watch: {
      items: function () {
        this.updateVisibleItems(!0);
      },
      pageMode: function () {
        this.applyPageMode(), this.updateVisibleItems(!1);
      },
      sizes: {
        handler: function () {
          this.updateVisibleItems(!1);
        },
        deep: !0,
      },
    },
    created: function () {
      (this.$_startIndex = 0),
        (this.$_endIndex = 0),
        (this.$_views = new Map()),
        (this.$_unusedViews = new Map()),
        (this.$_scrollDirty = !1),
        this.$isServer && this.updateVisibleItems(!1);
    },
    mounted: function () {
      this.applyPageMode(),
        this.$nextTick(() => {
          this.updateVisibleItems(!0), (this.ready = !0);
        });
    },
    beforeDestroy: function () {
      this.removeListeners();
    },
    methods: {
      addView: (e, t, i, n, r) => {
        const o = { item: i, position: 0 };
        const s = { id: I++, index: t, used: !0, key: n, type: r };
        return Object.defineProperty(o, 'nr', { configurable: !1, value: s }), e.push(o), o;
      },
      unuseView: function (e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i = this.$_unusedViews;
        const n = e.nr.type;
        let r = i.get(n);
        r || ((r = []), i.set(n, r)),
          r.push(e),
          t || ((e.nr.used = !1), (e.position = -9999), this.$_views.delete(e.nr.key));
      },
      handleResize: function () {
        this.$emit('resize'), this.ready && this.updateVisibleItems(!1);
      },
      handleScroll: function (e) {
        this.$_scrollDirty ||
          ((this.$_scrollDirty = !0),
          requestAnimationFrame(() => {
            (this.$_scrollDirty = !1),
              this.updateVisibleItems(!1).continuous ||
                (clearTimeout(this.$_refreshTimout), (this.$_refreshTimout = setTimeout(this.handleScroll, 100)));
          }));
      },
      handleVisibilityChange: function (e, t) {
        this.ready &&
          (e || 0 !== t.boundingClientRect.width || 0 !== t.boundingClientRect.height
            ? (this.$emit('visible'),
              requestAnimationFrame(() => {
                this.updateVisibleItems(!1);
              }))
            : this.$emit('hidden'));
      },
      updateVisibleItems: function (e) {
        const t = this.itemSize;
        const n = this.typeField;
        const r = this.simpleArray ? null : this.keyField;
        const o = this.items;
        const s = o.length;
        const l = this.sizes;
        const a = this.$_views;
        const c = this.$_unusedViews;
        const u = this.pool;
        let d = void 0;
        let h = void 0;
        let f = void 0;
        if (s)
          if (this.$isServer) (d = 0), (h = this.prerender), (f = null);
          else {
            const v = this.getScroll();
            const p = this.buffer;
            if (((v.start -= p), (v.end += p), null === t)) {
              let m = 0;
              let y = s - 1;
              let b = ~~(s / 2);
              let g = void 0;
              do {
                (g = b),
                  l[b].accumulator < v.start ? (m = b) : b < s - 1 && l[b + 1].accumulator > v.start && (y = b),
                  (b = ~~((m + y) / 2));
              } while (b !== g);
              for (b < 0 && (b = 0), d = b, f = l[s - 1].accumulator, h = b; h < s && l[h].accumulator < v.end; h++);
              -1 === h ? (h = o.length - 1) : ++h > s && (h = s);
            } else (d = ~~(v.start / t)), (h = Math.ceil(v.end / t)), d < 0 && (d = 0), h > s && (h = s), (f = s * t);
          }
        else d = h = f = 0;
        h - d > i.itemsLimit && this.itemsLimitError(), (this.totalSize = f);
        let _ = void 0;
        const w = d <= this.$_endIndex && h >= this.$_startIndex;
        let S = void 0;
        if (this.$_continuous !== w) {
          if (w) {
            a.clear(), c.clear();
            for (let $ = 0, z = u.length; $ < z; $++) (_ = u[$]), this.unuseView(_);
          }
          this.$_continuous = w;
        } else if (w)
          for (let x = 0, k = u.length; x < k; x++)
            (_ = u[x]).nr.used &&
              (e && (_.nr.index = o.findIndex((e) => (r ? e[r] === _.item[r] : e === _.item))),
              (-1 === _.nr.index || _.nr.index < d || _.nr.index >= h) && this.unuseView(_));
        w || (S = new Map());
        for (let I = void 0, D = void 0, V = void 0, O = void 0, T = d; T < h; T++) {
          I = o[T];
          const R = r ? I[r] : I;
          (_ = a.get(R)),
            t || l[T].size
              ? (_
                  ? ((_.nr.used = !0), (_.item = I))
                  : ((D = I[n]),
                    w
                      ? (V = c.get(D)) && V.length
                        ? (((_ = V.pop()).item = I),
                          (_.nr.used = !0),
                          (_.nr.index = T),
                          (_.nr.key = R),
                          (_.nr.type = D))
                        : (_ = this.addView(u, T, I, R, D))
                      : ((V = c.get(D)),
                        (O = S.get(D) || 0),
                        V && O < V.length
                          ? (((_ = V[O]).item = I),
                            (_.nr.used = !0),
                            (_.nr.index = T),
                            (_.nr.key = R),
                            (_.nr.type = D),
                            S.set(D, O + 1))
                          : ((_ = this.addView(u, T, I, R, D)), this.unuseView(_, !0)),
                        O++),
                    a.set(R, _)),
                (_.position = null === t ? l[T - 1].accumulator : T * t))
              : _ && this.unuseView(_);
        }
        return (
          (this.$_startIndex = d),
          (this.$_endIndex = h),
          this.emitUpdate && this.$emit('update', d, h),
          { continuous: w }
        );
      },
      getListenerTarget: function () {
        let e = g(this.$el);
        return (
          !window.document || (e !== window.document.documentElement && e !== window.document.body) || (e = window), e
        );
      },
      getScroll: function () {
        const e = this.$el;
        const t = 'vertical' === this.direction;
        let i = void 0;
        if (this.pageMode) {
          const n = e.getBoundingClientRect();
          const r = t ? n.height : n.width;
          let o = -(t ? n.top : n.left);
          let s = t ? window.innerHeight : window.innerWidth;
          o < 0 && ((s += o), (o = 0)), o + s > r && (s = r - o), (i = { start: o, end: o + s });
        } else
          i = t
            ? { start: e.scrollTop, end: e.scrollTop + e.clientHeight }
            : { start: e.scrollLeft, end: e.scrollLeft + e.clientWidth };
        return i;
      },
      applyPageMode: function () {
        this.pageMode ? this.addListeners() : this.removeListeners();
      },
      addListeners: function () {
        (this.listenerTarget = this.getListenerTarget()),
          this.listenerTarget.addEventListener('scroll', this.handleScroll, !!x && { passive: !0 }),
          this.listenerTarget.addEventListener('resize', this.handleResize);
      },
      removeListeners: function () {
        this.listenerTarget &&
          (this.listenerTarget.removeEventListener('scroll', this.handleScroll),
          this.listenerTarget.removeEventListener('resize', this.handleResize),
          (this.listenerTarget = null));
      },
      scrollToItem: function (e) {
        let t = void 0;
        (t = null === this.itemSize ? (e > 0 ? this.sizes[e - 1].accumulator : 0) : e * this.itemSize),
          this.scrollToPosition(t);
      },
      scrollToPosition: function (e) {
        'vertical' === this.direction ? (this.$el.scrollTop = e) : (this.$el.scrollLeft = e);
      },
      itemsLimitError: function () {
        throw (
          (setTimeout(() => {
            console.log(
              "It seems the scroller element isn't scrolling, so it tries to render all the items at once.",
              'Scroller:',
              this.$el,
            ),
              console.log(
                "Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.",
              );
          }),
          new Error('Rendered items limit reached'))
        );
      },
    },
  };
  const V = {
    render: function () {
      const t = this.$createElement;
      const i = this._self._c || t;
      return i(
        'RecycleScroller',
        this._g(
          this._b(
            {
              ref: 'scroller',
              attrs: {
                items: this.itemsWithSize,
                'min-item-size': this.minItemSize,
                direction: this.direction,
                'key-field': 'id',
              },
              on: { resize: this.onScrollerResize, visible: this.onScrollerVisible },
              scopedSlots: this._u([
                {
                  key: 'default',
                  fn: (t) => {
                    const i = t.item;
                    const n = t.index;
                    const r = t.active;
                    return [this._t('default', null, null, { item: i.item, index: n, active: r, itemWithSize: i })];
                  },
                },
              ]),
            },
            'RecycleScroller',
            this.$attrs,
            !1,
          ),
          this.listeners,
        ),
        [
          i('template', { slot: 'before' }, [this._t('before')], 2),
          this._v(' '),
          i('template', { slot: 'after' }, [this._t('after')], 2),
        ],
        2,
      );
    },
    staticRenderFns: [],
    name: 'DynamicScroller',
    components: { RecycleScroller: D },
    inheritAttrs: !1,
    provide: function () {
      return { vscrollData: this.vscrollData, vscrollParent: this };
    },
    props: S({}, $, { minItemSize: { type: [Number, String], required: !0 } }),
    data: function () {
      return { vscrollData: { active: !0, sizes: {}, validSizes: {}, keyField: this.keyField, simpleArray: !1 } };
    },
    computed: {
      simpleArray: z,
      itemsWithSize: function () {
        for (
          let e = [], t = this.items, i = this.keyField, n = this.simpleArray, r = this.vscrollData.sizes, o = 0;
          o < t.length;
          o++
        ) {
          const s = t[o];
          const l = n ? o : s[i];
          let a = r[l];
          void 0 !== a || this.$_undefinedMap[l] || (this.$_undefinedSizes++, (this.$_undefinedMap[l] = !0), (a = 0)),
            e.push({ item: s, id: l, size: a });
        }
        return e;
      },
      listeners: function () {
        const e = {};
        for (const t in this.$listeners) 'resize' !== t && 'visible' !== t && (e[t] = this.$listeners[t]);
        return e;
      },
    },
    watch: {
      items: function () {
        this.forceUpdate(!1);
      },
      simpleArray: {
        handler: function (e) {
          this.vscrollData.simpleArray = e;
        },
        immediate: !0,
      },
      direction: function (e) {
        this.forceUpdate(!0);
      },
    },
    created: function () {
      (this.$_updates = []), (this.$_undefinedSizes = 0), (this.$_undefinedMap = {});
    },
    activated: function () {
      this.vscrollData.active = !0;
    },
    deactivated: function () {
      this.vscrollData.active = !1;
    },
    methods: {
      onScrollerResize: function () {
        this.$refs.scroller && this.forceUpdate(), this.$emit('resize');
      },
      onScrollerVisible: function () {
        this.$emit('vscroll:update', { force: !1 }), this.$emit('visible');
      },
      forceUpdate: function () {
        (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0] || this.simpleArray) &&
          (this.vscrollData.validSizes = {}),
          this.$emit('vscroll:update', { force: !0 });
      },
      scrollToItem: function (e) {
        const t = this.$refs.scroller;
        t?.scrollToItem(e);
      },
      getItemSize: function (e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
        const i = this.simpleArray ? (null != t ? t : this.items.indexOf(e)) : e[this.keyField];
        return this.vscrollData.sizes[i] || 0;
      },
      scrollToBottom: function () {
        const e = this;
        if (!this.$_scrollingToBottom) {
          this.$_scrollingToBottom = !0;
          const t = this.$el;
          this.$nextTick(() => {
            requestAnimationFrame(function i() {
              (t.scrollTop = t.scrollHeight),
                0 === e.$_undefinedSizes ? (e.$_scrollingToBottom = !1) : requestAnimationFrame(i);
            });
          });
        }
      },
    },
  };
  const O = {
    name: 'DynamicScrollerItem',
    inject: ['vscrollData', 'vscrollParent'],
    props: {
      item: { required: !0 },
      watchData: { type: Boolean, default: !1 },
      active: { type: Boolean, required: !0 },
      index: { type: Number, default: void 0 },
      sizeDependencies: { type: [Array, Object], default: null },
      emitResize: { type: Boolean, default: !1 },
      tag: { type: String, default: 'div' },
    },
    computed: {
      id: function () {
        return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField];
      },
      size: function () {
        return (this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id]) || 0;
      },
    },
    watch: {
      watchData: 'updateWatchData',
      id: function () {
        this.size || this.onDataUpdate();
      },
      active: function (e) {
        e && this.$_pendingVScrollUpdate === this.id && this.updateSize();
      },
    },
    created: function () {
      if (!this.$isServer) {
        (this.$_forceNextVScrollUpdate = null), this.updateWatchData();
        const t = (t) => {
          this.$watch(() => this.sizeDependencies[t], this.onDataUpdate);
        };
        for (const i in this.sizeDependencies) t(i);
        this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate),
          this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize);
      }
    },
    mounted: function () {
      this.vscrollData.active && this.updateSize();
    },
    beforeDestroy: function () {
      this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate),
        this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize);
    },
    methods: {
      updateSize: function () {
        this.active && this.vscrollData.active
          ? this.$_pendingSizeUpdate !== this.id &&
            ((this.$_pendingSizeUpdate = this.id),
            (this.$_forceNextVScrollUpdate = null),
            (this.$_pendingVScrollUpdate = null),
            this.active && this.vscrollData.active && this.computeSize(this.id))
          : (this.$_forceNextVScrollUpdate = this.id);
      },
      getBounds: function () {
        return this.$el.getBoundingClientRect();
      },
      updateWatchData: function () {
        this.watchData
          ? (this.$_watchData = this.$watch(
              'data',
              () => {
                this.onDataUpdate();
              },
              { deep: !0 },
            ))
          : this.$_watchData && (this.$_watchData(), (this.$_watchData = null));
      },
      onVscrollUpdate: function (e) {
        const t = e.force;
        !this.active && t && (this.$_pendingVScrollUpdate = this.id),
          (this.$_forceNextVScrollUpdate !== this.id && !t && this.size) || this.updateSize();
      },
      onDataUpdate: function () {
        this.updateSize();
      },
      computeSize: function (e) {
        this.$nextTick(() => {
          if (this.id === e) {
            const i = this.getBounds();
            const n = Math.round('vertical' === this.vscrollParent.direction ? i.height : i.width);
            n &&
              this.size !== n &&
              (this.vscrollParent.$_undefinedMap[e] &&
                (this.vscrollParent.$_undefinedSizes--, (this.vscrollParent.$_undefinedMap[e] = void 0)),
              this.$set(this.vscrollData.sizes, this.id, n),
              this.$set(this.vscrollData.validSizes, this.id, !0),
              this.emitResize && this.$emit('resize', this.id));
          }
          this.$_pendingSizeUpdate = null;
        });
      },
    },
    render: function (e) {
      return e(this.tag, this.$slots.default);
    },
  };
  const T = {
    version: '1.0.0-rc.2',
    install: (e, t) => {
      const n = Object.assign({}, { installComponents: !0, componentsPrefix: '' }, t);
      for (const r in n) void 0 !== n[r] && (i[r] = n[r]);
      n.installComponents &&
        ((e, t) => {
          e.component(`${t}recycle-scroller`, D),
            e.component(`${t}RecycleScroller`, D),
            e.component(`${t}dynamic-scroller`, V),
            e.component(`${t}DynamicScroller`, V),
            e.component(`${t}dynamic-scroller-item`, O),
            e.component(`${t}DynamicScrollerItem`, O);
        })(e, n.componentsPrefix);
    },
  };
  let R = null;
  return (
    'undefined' !== typeof window ? (R = window.Vue) : 'undefined' !== typeof global && (R = global.Vue),
    R?.use(T),
    (e.RecycleScroller = D),
    (e.DynamicScroller = V),
    (e.DynamicScrollerItem = O),
    (e.default = T),
    (e.IdState = () => {
      const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).idProp;
      const i = void 0 === e ? (e) => e.item.id : e;
      const n = {};
      const r = new t({ data: () => ({ store: n }) });
      return {
        data: () => ({ idState: null }),
        created: function () {
          (this.$_id = null),
            (this.$_getId = 'function' === typeof i ? () => i.call(this, this) : () => this[i]),
            this.$watch(this.$_getId, {
              handler: function (e) {
                this.$nextTick(() => {
                  this.$_id = e;
                });
              },
              immediate: !0,
            }),
            this.$_updateIdState();
        },
        beforeUpdate: function () {
          this.$_updateIdState();
        },
        methods: {
          $_idStateInit: function (e) {
            const t = this.$options.idState;
            if ('function' === typeof t) {
              const i = t.call(this, this);
              return r.$set(n, e, i), (this.$_id = e), i;
            }
            throw new Error('[mixin IdState] Missing `idState` function on component definition.');
          },
          $_updateIdState: function () {
            const e = this.$_getId();
            null == e && console.warn(`No id found for IdState with idProp: '${i}'.`),
              e !== this.$_id && (n[e] || this.$_idStateInit(e), (this.idState = n[e]));
          },
        },
      };
    }),
    e
  );
})({}, Vue);
